#ifndef DB_BTREE_LEAFPAGE_H
#define DB_BTREE_LEAFPAGE_H

#include <db/BTreePage.h>
#include <db/BTreePageId.h>
#include <db/Tuple.h>
#include <cstdint>
#include <cstring>

namespace db {
    class BTreeLeafPage;

    /**
     * Helper class that implements the Java Iterator for tuples on a BTreeLeafPage.
     */
    class BTreeLeafPageIterator {
        int index;
        BTreeLeafPage *page;
        bool reverse;
    public:
        BTreeLeafPageIterator() = default;
        BTreeLeafPageIterator(int index, BTreeLeafPage *page, bool reverse = false);

        bool operator!=(const BTreeLeafPageIterator &other) const;

        BTreeLeafPageIterator &operator++();

        Tuple &operator*() const;
    };

    /**
     * Each instance of BTreeLeafPage stores data for one page of a BTreeFile and
     * implements the Page interface that is used by BufferPool.
     *
     * @see BTreeFile
     * @see BufferPool
     */
    class BTreeLeafPage : public BTreePage {
        friend class BTreeLeafPageIterator;

        uint8_t *header;
        Tuple *tuples;
        int numSlots;
        int leftSibling; // leaf node or 0
        int rightSibling; // leaf node or 0

        /**
         * Computes the number of bytes in the header of a page in a BTreeFile with each tuple occupying tupleSize bytes
         */
        size_t getHeaderSize() const;

        /**
         * Read tuples from the source file.
         */
        void readTuple(Tuple *t, uint8_t *data, int slotId);


        /**
         * Move a record from one slot to another slot, and update the corresponding
         * headers and RecordId
         */
        void moveRecord(int from, int to);


        /**
         * Abstraction to fill or clear a slot on this page.
         */
        void markSlotUsed(int i, bool value);

    public:

        /**
         * Create a BTreeLeafPage from a set of bytes of data read from disk.
         * The format of a BTreeLeafPage is a set of header bytes indicating
         * the slots of the page that are in use, and some number of tuple slots,
         * as well as some extra bytes for the parent and sibling pointers.
         *  Specifically, the number of tuples is equal to: <p>
         *          floor((BufferPool.getPageSize()*8 - extra bytes*8) / (tuple size * 8 + 1))
         * <p> where tuple size is the size of tuples in this
         * database table, which can be determined via {@link Catalog#getTupleDesc}.
         * The number of 8-bit header words is equal to:
         * <p>
         *      ceiling(no. tuple slots / 8)
         * <p>
         * @see Database#getCatalog
         * @see Catalog#getTupleDesc
         * @see BufferPool#getPageSize()
         *
         * @param id - the id of this page
         * @param data - the raw data of this page
         * @param key - the field which the index is keyed on
         */
        BTreeLeafPage(const BTreePageId &id, uint8_t *data, int key);

        /**
         * Retrieve the maximum number of tuples this page can hold.
         */
        size_t getMaxTuples() const;

        /**
         * Generates a byte array representing the contents of this page.
         * Used to serialize this page to disk.
         * <p>
         * The invariant here is that it should be possible to pass the byte
         * array generated by getPageData to the BTreeLeafPage constructor and
         * have it produce an identical BTreeLeafPage object.
         *
         * @see #BTreeLeafPage
         * @return A byte array corresponding to the bytes of this page.
         */
        void *getPageData() const override;

        /**
         * Delete the specified tuple from the page;  the tuple should be updated to reflect
         *   that it is no longer stored on any page.
         * @param t The tuple to delete
         */
        void deleteTuple(Tuple *t);

        /**
         * Adds the specified tuple to the page such that all records remain in sorted order;
         * the tuple should be updated to reflect
         *  that it is now stored on this page.
         * @param t The tuple to add.
         */
        void insertTuple(Tuple *t);

        /**
         * Get the id of the left sibling of this page
         * @return the id of the left sibling
         */
        BTreePageId *getLeftSiblingId();

        /**
         * Get the id of the right sibling of this page
         * @return the id of the right sibling
         */
        BTreePageId *getRightSiblingId();

        /**
         * Set the left sibling id of this page
         * @param id - the new left sibling id
         * @throws DbException if the id is not valid
         */
        void setLeftSiblingId(BTreePageId *id);

        /**
         * Set the right sibling id of this page
         * @param id - the new right sibling id
         * @throws DbException if the id is not valid
         */
        void setRightSiblingId(BTreePageId *id);

        /**
         * Returns the number of tuples currently stored on this page
         */
        int getNumTuples();

        /**
         * Returns the number of empty slots on this page.
         */
        int getNumEmptySlots() const override;

        /**
         * Returns true if associated slot on this page is filled.
         */
        bool isSlotUsed(int i) const override;

        /**
         * @return an iterator over all tuples on this page (calling remove on this iterator throws an UnsupportedOperationException)
         * (note that this iterator shouldn't return tuples in empty slots!)
         */
        BTreeLeafPageIterator begin();

        BTreeLeafPageIterator end();

        /**
         * @return a reverse iterator over all tuples on this page (calling remove on this iterator throws an UnsupportedOperationException)
         * (note that this iterator shouldn't return tuples in empty slots!)
         */
        BTreeLeafPageIterator rbegin();

        BTreeLeafPageIterator rend();

        /**
         * protected method used by the iterator to get the ith tuple out of this page
         * @param i - the index of the tuple
         * @return the ith tuple in the page
         */
        Tuple *getTuple(int i);

        void readTuples(uint8_t *data);
    };
}

#endif
